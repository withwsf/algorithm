###　经典问题
> 将说明并实现一些经典的问题
*　最大子序列的问题
#### 1.这个问题最直观的解法是复杂度Ｏ(N^３)的解法----计算子序列的tail是原序列中的某个元素时，取不同head的子序列的元素加和并取最大者，对于Ｎ个不同的tail计算值再取最大值，就计算出了结果。但不能满足于此，还要进行进一步的优化。实际上，计算每个可能的子序列的和是产生了重复计算，如果能够减少这些重复计算，可以将复杂度降到Ｏ(N^2).

#### 2.上述Ｏ(N^2)的方法并没有完全避免重复计算，更后面的tail求submax的计算包括了在前面的tail时已经计算过的事情。考虑使用分治算法，将一个待求的序列分为左右两部分，那么最大的子序列要么在左边，要么在右边，要么横跨两条子序列，使用递归的方法计算前两个，手工计算第三个，并返回三个中的最大值（当然，递归的终止条件是序列长度为１时）。这个算法的时间复杂度是Ｏ(NlogN)。

#### 3.如果注意思考，可以想到，只要靠近head的子序列的加和是正的，就可以为继续寻找更大的子序列做贡献，就应该包含在我们的寻找中，依据这个简单的想法可以找到时间复杂度为０(N)的算法。

