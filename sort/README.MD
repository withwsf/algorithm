#### 关于sort算法的简短总结
* 插入排序：把每次从未排序的元素中拿出一个来插入倒已经排序的元素中的合适位置，时间复杂度为O(n^2)；
* 冒泡排序:每次从未排序的元素中选出一个最大（最小也可以，那就是逆序）的，放到已经排序的元素队列的头部,时间复杂度与插入排序相同；
* Shell排序：首次将排序的时间复杂度降到O(n^2)以下的算法，具体的时间复杂度为Ｏ(n*logn^2)。Shell排序是插入排序的改进，具体说来，先将原先序列分成stepsize个子序列，对个子序列进行插入排序，只要最后的stepsize=1就可以保证排序完成。Stepsize序列的选择对性能有着影响。具体的完成看代码。
* MergeSort:　将要分类的序列从中间劈开，然后分别对两个子序列进行分类，将分类后的结果进行合并，因而取名为归并排序。归并的过程很有趣，首先是从，嗳，看代码吧。这里使用了template进行编程，需要注意的一个是用法，template<typename T>,然后把Ｔ当成普通的类型适用就行了；另外，一个是，要把模板函数的实现放在头文件中，或者另外建一个头文件include声明头文件并存放实现。为了节省vector<T> temp的创建销毁时间，只创建了一次，然后传递引用的方式进行使用。
* QuickSort: 快速排序也是使用分治法进行排序的算法，只不过没有合并的过程。其主要过程是每次从待排序的数组中“随机”选出一个数，然后把小于此数的数组元素放在此数左边，大于此数的数组元素放到此数的右边，然后对问题规模较小的两个子问题进行递归计算，递归的终止条件是数组的长度小于等于１.快排比较复杂，涉及到如何选取那个“中间数”，如何处理相等的情况，当数组长度为２的边界情况（判断ａ[ptri]与ａ[tail]的大小状况来处理）等。具体的情况看维基百科和代码。
